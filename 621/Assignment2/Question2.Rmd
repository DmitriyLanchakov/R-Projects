---
title: "Question2"
author: "Saeed Rahman"
date: "March 8, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### A)

Implement a trinomial tree to price European, American Call and Put op-
tions.

```{r}
library(quantmod)
library(rCharts)
library(reshape)

TrinomialTree = function(isCall, isAmerican=FALSE, K, Tm, 
                      S0, r, sig, N, div=0, dx=0,show=FALSE)
{
  # Precompute constants ----
  dt = Tm/N 
  nu = r - div - 0.5 * sig^2
  if(dx==0)
    # dx=sig*sqrt(3*T/N)
    dx = sig*sqrt(3*dt) #Condition in the question
  pu = 0.5 * ( (sig^2*dt + nu^2 *dt^2)/dx^2 + nu*dt/dx ) #up move probability
  pm = 1.0 -   (sig^2*dt + nu^2 *dt^2)/dx^2 #Side move probability
  pd = 0.5 * ( (sig^2*dt + nu^2 *dt^2)/dx^2 - nu*dt/dx ) # down move probability.
  #pu+pm+pd not necessarily equal to 1
  disc = exp(-r*dt) #Discount rate
  nRows = 2*N+1 #number of rows 
  nCols = N+1 #number of columns
  cp = ifelse(isCall, 1, -1) #to check if call or put
  # Intialize an empty matrix  ----
  V = S = matrix(0, nrow=nRows, ncol=nCols, dimnames=list(
    paste("NumUps", N:-N, sep="="), paste("T", 0:N, sep="=")))
  #Initial stock value
  S[nCols, 1] = S0
  #Fill in the stock matrix with the stock values over different states
  for (j in 1:N) {
    for(i in (nCols-j+1):(nCols+j-1)) {
      S[i-1, j+1] = S[i, j] * exp(dx)
      S[i ,  j+1] = S[i, j] 
      S[i+1, j+1] = S[i, j] * exp(-dx)
    }
  }
  # Intialize option values at maturity ----
  for (i in 1:nRows) {
    V[i, N+1] = max( 0, cp * (S[i, N+1]-K))
  }
  V
  # Step backwards through the tree ----
  for (j in (nCols-1):1) {
    for(i in (nCols-j+1):(nCols+j-1)) {
      #converging from N to N-1 state diagonally
      V[i, j] = disc * (pu*V[i-1,j+1] + pm*V[i, j+1] + pd*V[i+1,j+1])
      if(isAmerican) {
        V[i, j] = max(V[i, j], cp * (S[i, j] - K))
      }
    }
  }
  V
  if(show){
    print("Stock Tree")
    print(S)
    print("Option Value Tree")
    print(V)
  }
  else
    return(V[N+1,1])
}

TrinomialTree(isCall=T, isAmerican=F, K=100, T=1.0, div=0.03, S0=100, sig=0.2, r=0.06, N=5,show = TRUE)
print(paste("European Call Price=",TrinomialTree(isCall=T, isAmerican=F, K=100, T=1.0, div=0.03, S0=100, sig=0.2, r=0.06, N=200)))
print(paste("American Call Price=",TrinomialTree(isCall=T, isAmerican=T, K=100, T=1.0, div=0.03, S0=100, sig=0.2, r=0.06, N=200)))
print(paste("European Put Price=",TrinomialTree(isCall=F, isAmerican=F, K=100, T=1.0, div=0.03, S0=100, sig=0.2, r=0.06, N=200)))
print(paste("American Put Price=",TrinomialTree(isCall=F, isAmerican=T, K=100, T=1.0, div=0.03, S0=100, sig=0.2, r=0.06, N=200)))
```

### B)
####Calculating Implied Volatility
```{r pressure, echo=FALSE}

library(quantmod)
#Black sholes merton pricing function----
BSM<-function(S, K, t, r, sigma,type){
  d1 <- (log(S/K)+(r+sigma^2/2)*t)/(sigma*sqrt(t))
  d2 <- d1 - sigma * sqrt(t)
  if (type == "c")
    result <- S*pnorm(d1) - K*exp(-r*t)*pnorm(d2)
  if (type == "p")
    result <- K*exp(-r*t) * pnorm(-d2) - S*pnorm(-d1)
  return(result)
}
#Calculating Implied Vol----
#Implementation of secant method that was used in assignment 1, Used secant method for the advantage in speed 
Secant <- function(S, K, t, r, type, option_price
                             , x0=0.1, x1=3, tolerance=1e-07, max.iter=10000){
  x1=3
  theta=.00001
  fun.x1=BSM(S=S,K=K,t=t,r=r,sigma=x1,type=type)-option_price
  count=1
  start.time <- Sys.time()
  while(abs(fun.x1) > tolerance && count<max.iter) {
    x2=x1-theta
    fun.x1=BSM(S=S,K=K,t=t,r=r,sigma=x1,type=type)-option_price
    fun.x2=BSM(S=S,K=K,t=t,r=r,sigma=x2,type=type)-option_price
    x1 <- x1- fun.x1/((fun.x1-fun.x2)/theta)   
    count <-count+1
  }
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  if(x2<0 || count>=max.iter)
    return(list(NA,time.taken,count))
  else
    return(list(x2,time.taken,count))
}

#Calculating IV on the option chain using secant method
ImpliedVol_Secant<-function(symbol="AAPL",option_chain,rate=.75/100){
  symbol="AAPL"
  stock_df<-as.data.frame(getSymbols(symbol,from = as.Date("2017-01-01"),to=as.Date("2017-02-19"), env = NULL))

  iv <- {}
  original_iv <-{}
  optionName <-{}
  strike <-{}
  days_till_expiry <-{}
  time.taken <- 0
  iterations <- 0
  type <-{}
  bid<-{}
  ask<-{}
  for (i in 1:nrow(option_chain)) 
  {
    try({
      #Myoldmethod----
       secant <- Secant(
       S = as.numeric(tail(stock_df,1)[6]),
       K = as.numeric(option_chain[i,"Strike"]),
       t = as.numeric(option_chain[i,"days_till_expiry"])/252,
       r = rate,
       type = ifelse((option_chain[i,"Type"]=="Call"), "c", "p"),
       option_price = as.numeric(option_chain[i,"premium"]))

       iv <- append(iv,as.numeric(secant[1]))

       if(!is.na(secant[1])){
        time.taken <- as.numeric(secant[2])+time.taken
        iterations <- as.numeric(secant[3])+iterations
       }
      type <- append(type,as.character(option_chain[i,"Type"]))
      
      strike<-append(strike,as.numeric(option_chain[i,"Strike"]))
      
      optionName <- append(optionName,paste(option_chain[i,"Strike"],"-",
                                            option_chain[i,"Type"],"Expiring On:",
                                            option_chain[i,"Expiry"]))
      days_till_expiry <- append(days_till_expiry,as.numeric(option_chain[i,"days_till_expiry"]))
      
      bid<-append(bid,as.numeric(option_chain[i,"Bid"]))
      ask<-append(ask,as.numeric(option_chain[i,"Ask"]))
    })
  }
  option_chain_df <- data.frame(days_till_expiry,type,optionName,iv,strike,bid,ask)
  names(option_chain_df)<-c("Days_till_Expiry","Type","Specification","Implied_Volatility","Strike","Bid","Ask")
  time.taken <- time.taken/as.numeric(colSums(!is.na(option_chain_df))[3])
  iterations <- iterations/as.numeric(colSums(!is.na(option_chain_df))[3])
  list(option_chain_df,time.taken,iterations)
}
```

####Importing the data from the CSV files and calculating the IV 
```{r, message=FALSE, warning=FALSE}
option_chain_call_csv <- read.csv(file="call.csv",header=TRUE, sep=",")
option_chain_put_csv <-read.csv(file="put.csv",header=TRUE, sep=",")
#call.csv and put.csv are available in the project folder
#Call
option_chain_call_csv$days_till_expiry <- as.Date(option_chain_call_csv$Expiry,"%m/%d/%Y")-as.Date("2017-02-19")
#Put
option_chain_put_csv$days_till_expiry <- as.Date(option_chain_put_csv$Expiry,"%Y/%m/%d")-as.Date("2017-02-19")
#Calculating the days till expiry
option_chain_call_csv$premium<-(option_chain_call_csv$Bid+option_chain_call_csv$Ask)/2

option_chain_put_csv$premium<-(option_chain_put_csv$Bid+option_chain_put_csv$Ask)/2

df=ImpliedVol_Secant(option_chain = option_chain_call_csv)
df=as.data.frame(df[1])
options.df_call=df[complete.cases(df$Implied_Volatility),]

df=ImpliedVol_Secant(option_chain = option_chain_put_csv)
df=as.data.frame(df[1])
options.df_put=df[complete.cases(df$Implied_Volatility),]

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
