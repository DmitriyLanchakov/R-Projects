---
title: "Question3"
author: "Saeed Rahman"
date: "March 8, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### A)
Construct a binomial tree to calculate the price of an European Up-and-Out
call option. Use S 0 = 10, strike K = 10, maturity T = 0.3, volatility σ = 0.2,
short rate r = 0.01, dividends δ = 0, and barrier H = 11. Use as many steps
in your tree as you think are necessary

```{r}
#Exotic using old binomial tree method----
BinomialTreeExotic = function(isCall, isAmerican=FALSE, K=100, Tm=1, 
                           S0=100, r=0.06, sig=0.2, N=3, u=1.1, d=1/u,div=0,type,barrier=100)
{
  dt = Tm/N
  nu=r-div-0.5*sig*sig
  dxu=sqrt(sig*sig*dt+((nu*dt)^2))
  dxd=-dxu
  pu=0.5+0.5*(nu*dt/dxu)
  pd=1-pu
  disc=exp(-r*dt)
  #
  # dpu=disc*pu
  # dpd=disc*pd
  # edxud=exp(dxu-dxd)
  # edxd=exp(dxd)
  
  # Precompute constants ----
  dt = Tm/N # diving the time into partition, to get time for each state
  disc = exp(-r*dt)
  p = (exp(r*dt)-d)/(u-d) #calculating the probability of up move
  nRows = 2*N+1 #number of rows for the matrix
  nCols = N+1 #number of columns
  cp = ifelse(isCall, 1, -1) # to check ifts a call or a put
  
  # Intialize asset prices  ----
  # Creating a matrix of nRows*nColumns with zeros and headings 
  V = S = matrix(0, nrow=nRows, ncol=nCols, dimnames=list(
    paste("NumUps", N:-N, sep="="), paste("T", 0:N, sep="=")))
  S[nCols, 1] = S0 # initial stock price
  
  # iterating the elements of the matrix in a conical manner starting
  # from the position of initial stock price
  # For n=3, S[i,j]= S0, then update the forward diagonal elements 
  # Code is similar to the one used for trinomial tree
  for (j in 1:N) {
    for(i in (nCols-j+1):(nCols+j-1)) {
      S[i-1, j+1] = S[i, j]*exp(dxu)
      S[i+1, j+1] = S[i, j] *exp(dxd)
    }
  }
  print(S)
  for (i in 1:nRows) {
    if(type=="UO"){
      V[i,nCols] <- ifelse((S[i,nCols]<barrier),max(0,cp * (S[i, nCols]-K)),0)
    }
    else if(type=="UI")
      V[i,nCols] <- ifelse((S[i,nCols]>barrier),max(0,cp * (S[i, nCols]-K)),0)
    # V[i, nCols] = max( 0, (cp * (S[i, nCols]-K))
      
  }
  print(V)
  # V
  # Step backwards through the tree ----
  for (j in (nCols-1):1) {
    for(i in (nCols-j+1):(nCols+j-1)) {
      # V[i, j] = disc * (p*V[i-1,j+1] + (1-p)*V[i+1,j+1])
      V[i, j] = disc * (pu*V[i-1,j+1] + pd*V[i+1,j+1])
      # if(isAmerican) {
      #   # if american option, then take the Value at each node as the max of the
      #   # value of option or the payoff at that period
      #   V[i, j] = max(V[i, j], cp * (S[i, j] - K))
      if(type=="UO" && S[i,j]>=barrier){
        V[i,j] <- 0
      }
      else if(type=="UI" && S[i,j]<=barrier){
        
        V[i,j] <- 0
      # V[i, nCols] = max( 0, (cp * (S[i, nCols]-K))
      }
    } 
  }
  print(V)
  return(V[nCols,1])
}
  
BinomialTreeExotic(isCall=TRUE,K=10,Tm =.3 ,S0 =10 ,sig = .2,N =200,r=.01,type = "UO",barrier = 11)
BinomialTreeOld(isCall=FALSE,K=100,Tm =1 ,S0 =100 ,sig = .2,N =200,r=.06)
BinomialTreeOld(isCall=TRUE,isAmerican = TRUE,K=100,Tm =1 ,S0 =100 ,sig = .2,N =200,r=.06)
BinomialTreeOld(isCall=FALSE,isAmerican = TRUE,K=100,Tm =1 ,S0 =100 ,sig = .2,N =200,r=.06)

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
